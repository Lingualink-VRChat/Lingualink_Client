# LinguaLink Client 循环调用问题修复总结

## 问题描述

在增加或减少语言时出现堆栈溢出错误，错误信息显示存在循环调用，重复执行了601次相同的调用栈。

## 错误调用栈分析

1. `OnGlobalSettingsChanged()` 行 120
2. `SettingsChangedNotifier.RaiseSettingsChanged()` 行 12  
3. `IndexWindowViewModel.SaveCurrentSettings()` 行 534
4. `IndexWindowViewModel.OnLanguageSelectionChanged()` 行 490
5. `SelectableTargetLanguageViewModel.OnSelectedBackendLanguageChanged()` 行 114
6. `SelectableTargetLanguageViewModel.SelectedBackendLanguage.set()` 行 26
7. `SelectableTargetLanguageViewModel` 构造函数 行 55
8. `IndexWindowViewModel.LoadTargetLanguagesFromSettings()` 行 451
9. `IndexWindowViewModel.LoadSettingsAndInitializeServices()` 行 151
10. 又回到第1步，形成循环

## 问题根本原因

**循环调用的核心问题：在初始化和设置加载过程中触发了设置保存操作**

具体来说：
1. 设置变更时触发 `OnGlobalSettingsChanged`
2. 这导致重新加载设置并初始化服务
3. 重新创建 `SelectableTargetLanguageViewModel` 实例
4. 在构造函数中设置 `SelectedBackendLanguage` 属性
5. 这触发了 `OnSelectedBackendLanguageChanged` 回调
6. 回调通知父级 `IndexWindowViewModel`
7. 父级调用 `SaveCurrentSettings` 保存设置
8. 保存设置又触发了 `SettingsChangedNotifier`
9. 回到第1步，形成无限循环

## 解决方案

### 1. 在 `SelectableTargetLanguageViewModel` 中添加初始化标志

```csharp
// 添加初始化标志，防止在初始化期间触发事件回调
private bool _isInitializing = true;

// 在构造函数最后设置为 false
_isInitializing = false;

// 在属性变更回调中检查标志
partial void OnSelectedBackendLanguageChanged(string oldValue, string newValue)
{
    // 只有在非初始化状态时才通知父级视图模型
    if (!_isInitializing)
    {
        ParentViewModel?.OnLanguageSelectionChanged(this);
    }
}
```

### 2. 在 `UpdateAvailableLanguages` 方法中临时禁用回调

```csharp
public void UpdateAvailableLanguages(List<string> backendLanguages)
{
    // 临时设置标志，防止在更新时触发回调
    bool wasInitializing = _isInitializing;
    _isInitializing = true;
    
    try
    {
        // ... 更新逻辑
        SelectedDisplayLanguage = AvailableLanguages.FirstOrDefault(item => item.BackendName == currentSelectedBackend);
    }
    finally
    {
        // 恢复原来的标志状态
        _isInitializing = wasInitializing;
    }
}
```

### 3. 在 `IndexWindowViewModel` 中添加设置加载标志

```csharp
// 添加标志防止在设置加载期间触发设置保存，避免循环调用
private bool _isLoadingSettings = false;

// 在 LoadTargetLanguagesFromSettings 中使用
private void LoadTargetLanguagesFromSettings(AppSettings settings)
{
    _isLoadingSettings = true;
    try
    {
        // ... 加载设置逻辑
    }
    finally
    {
        _isLoadingSettings = false;
    }
}

// 在 OnLanguageSelectionChanged 中检查标志
public void OnLanguageSelectionChanged(SelectableTargetLanguageViewModel changedItem)
{
    UpdateItemPropertiesAndAvailableLanguages();
    
    // 只有在不是加载设置期间才保存当前设置，避免循环调用
    if (!_isLoadingSettings)
    {
        SaveCurrentSettings();
    }
}
```

## 修复效果

通过以上修复：

1. **初始化期间**：`SelectableTargetLanguageViewModel` 在构造时不会触发设置保存
2. **设置加载期间**：`IndexWindowViewModel` 在加载设置时不会触发设置保存
3. **更新可用语言期间**：不会触发不必要的回调
4. **正常用户操作**：仍然会正确保存设置

这样既保持了正常的功能，又避免了循环调用导致的堆栈溢出问题。

## 测试建议

1. 测试添加语言功能
2. 测试删除语言功能
3. 测试更改语言选择
4. 测试应用启动时的设置加载
5. 测试设置页面的配置更改

确保所有操作都不会引发堆栈溢出错误，同时功能正常。 